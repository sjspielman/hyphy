function protein_gtr.save_options() {
    protein_gtr.analysis_results[utility.getGlobalValue("terms.json.options")] = {utility.getGlobalValue("protein_gtr.options.frequency_type"): protein_gtr.frequency,
                                                                                  utility.getGlobalValue("protein_gtr.options.baseline_model"): protein_gtr.baseline_model};

    protein_gtr.analysis_results[utility.getGlobalValue("terms.json.input")] = {utility.getGlobalValue("terms.json.file"): protein_gtr.listfile,
                                                                                "number of datasets": protein_gtr.file_list_count};

    /* Temporarily, we save input file information here in a highly redundant fashion, but doesn't seem possible to do in MPI...? */
    for (file_index = 0; file_index < protein_gtr.file_list_count; file_index += 1) {
    
        filename = protein_gtr.file_list[file_index];
        utility.EnsureKey(protein_gtr.analysis_results, file_index);  
    
        protein_gtr.file_info = alignments.ReadNucleotideDataSet ("protein_gtr.msa",
                                                                      filename);
        protein_gtr.name_mapping = protein_gtr.file_info[utility.getGlobalValue("terms.data.name_mapping")];
        if (None == protein_gtr.name_mapping) { /** create a 1-1 mapping if nothing was done */
            protein_gtr.name_mapping = {};
            utility.ForEach (alignments.GetSequenceNames ("protein_gtr.msa"), "_value_", "`&protein_gtr.name_mapping`[_value_] = _value_");
        }
        utility.ToggleEnvVariable ("GLOBAL_FPRINTF_REDIRECT", "/dev/null");
        ExecuteCommands ('protein_gtr.partitions_and_trees = trees.LoadAnnotatedTreeTopology.match_partitions (protein_gtr.file_info[terms.data.partitions], protein_gtr.name_mapping)',
                          {"0" : "Y"});
        utility.ToggleEnvVariable ("GLOBAL_FPRINTF_REDIRECT", None);


        protein_gtr.filter_specification = alignments.DefineFiltersForPartitions (protein_gtr.partitions_and_trees,
                                                                                    "protein_gtr.msa" ,
                                                                                    "protein_gtr.filter.",
                                                                                    protein_gtr.file_info);
        protein_gtr.tree = utility.Map (protein_gtr.partitions_and_trees, "_value_", '_value_[terms.data.tree]');


        protein_gtr.output_data_info = { utility.getGlobalValue("terms.json.sequences"): protein_gtr.file_info[utility.getGlobalValue("terms.data.sequences")],
                                         utility.getGlobalValue("terms.json.sites"): protein_gtr.file_info[utility.getGlobalValue("terms.data.sites")],
                                         utility.getGlobalValue("terms.json.trees"): (protein_gtr.tree["0"])[utility.getGlobalValue("terms.trees.newick_with_lengths")],
                                         utility.getGlobalValue("terms.json.file"): filename,
                                         utility.getGlobalValue("terms.original_name"): {}
                                       };
        
        
        //In case there were no branch lengths
        if (  Abs( (protein_gtr.tree["0"])[utility.getGlobalValue("terms.branch_length")] ) == 0 ){
            protein_gtr.output_data_info[ utility.getGlobalValue("terms.json.trees") ] = (protein_gtr.full_trees["0"])[utility.getGlobalValue("terms.trees.newick")];
        }
        utility.ForEach (utility.Keys (protein_gtr.name_mapping), "branch_name",
                                 "utility.EnsureKey (protein_gtr.output_data_info[terms.original_name], branch_name)");
        
        utility.ForEach (utility.Keys (protein_gtr.name_mapping), "branch_name",
                                 "(protein_gtr.output_data_info[terms.original_name])[branch_name] = protein_gtr.name_mapping[branch_name]");
        
        
        (protein_gtr.analysis_results[file_index])[utility.getGlobalValue("terms.json.input")] = protein_gtr.output_data_info;   
    }
}






lfunction protein_gtr.startTimer(timers, key) {
    timers[key] = {
        utility.getGlobalValue("terms.timers.timer"): Time(1),
    };

}
lfunction protein_gtr.stopTimer(timers, key) {
    (timers[key])[utility.getGlobalValue("terms.timers.timer")] = Time(1) - (timers[key])[utility.getGlobalValue("terms.timers.timer")];
}



/*************************************************************************************************/
/**
 * @name models.protein.Baseline.ModelDescription.withGamma
 * @description Define baseline (standard matrix) model w/ +F and *no* four-category gamma rate variation
 */
function protein_gtr.Baseline.ModelDescription(type){
    def = Call( models.protein.empirical.plusF_generators[protein_gtr.baseline_model], type);
    return def;
}
/**
 * @name models.protein.Baseline.ModelDescription.withGamma
 * @description Define baseline (standard matrix) model w/ +F and *yes* four-category gamma rate variation
 */
function protein_gtr.Baseline.ModelDescription.withGamma(type){
    def = protein_gtr.Baseline.ModelDescription(type);
	def [utility.getGlobalValue("terms.model.rate_variation")] = rate_variation.types.Gamma.factory ({utility.getGlobalValue("terms.rate_variation.bins") : 4});
    return def;
}




/**
 * @name protein_gtr.REV.ModelDescription.freqs
 * @description Define REV model frequencies as empirical
 */
function protein_gtr.REV.ModelDescription.freqs (model, namespace, datafilter) {
    model[terms.efv_estimate] = protein_gtr.shared_EFV;
    model[terms.model.efv_estimate_name] = terms.frequencies.predefined;
    (model[terms.parameters])[terms.model.empirical] = 0;
    return model;
}

/**
 * @name protein_gtr.REV.ModelDescription
 * @description Define a REV model with constant site rates
 */
function protein_gtr.REV.ModelDescription (type) {
    def = models.protein.REV.ModelDescription(type);
    if (Type (protein_gtr.shared_EFV) == "Matrix") {
        def [terms.model.frequency_estimator] = "protein_gtr.REV.ModelDescription.freqs";
    }
    return def;
}

/**
 * @name protein_gtr.REV.ModelDescription.withGamma
 * @description Define a REV model with Gamma rate variation
 */
function protein_gtr.REV.ModelDescription.withGamma (type) {
    def = protein_gtr.REV.ModelDescription(type);
    def [utility.getGlobalValue("terms.model.rate_variation")] = rate_variation.types.Gamma.factory ({utility.getGlobalValue("terms.rate_variation.bins"): 4});
    return def;
}
/*************************************************************************************************/




/**
 * @name protein_gtr.fitBaselineToFile
 * @description Fits an empirical amino acid model to dataset for branch length optimization
 * @param {String} filename - The name of the file containing the dataset to which the amino acid model will be fitted
 * @return the fitted MLE
 */
function protein_gtr.fitBaselineToFile (filename) {
    
    
    utility.EnsureKey(protein_gtr.analysis_results, protein_gtr.index_to_filename[filename]);  
    
    protein_gtr.file_info = alignments.ReadNucleotideDataSet ("protein_gtr.msa",
                                                              filename);
    protein_gtr.name_mapping = protein_gtr.file_info[utility.getGlobalValue("terms.data.name_mapping")];
    if (None == protein_gtr.name_mapping) { /** create a 1-1 mapping if nothing was done */
        protein_gtr.name_mapping = {};
        utility.ForEach (alignments.GetSequenceNames ("protein_gtr.msa"), "_value_", "`&protein_gtr.name_mapping`[_value_] = _value_");
    }
    utility.ToggleEnvVariable ("GLOBAL_FPRINTF_REDIRECT", "/dev/null");
    ExecuteCommands ('protein_gtr.partitions_and_trees = trees.LoadAnnotatedTreeTopology.match_partitions (protein_gtr.file_info[terms.data.partitions], protein_gtr.name_mapping)',
                     {"0" : "Y"});
    utility.ToggleEnvVariable ("GLOBAL_FPRINTF_REDIRECT", None);



    protein_gtr.partition_count      = Abs (protein_gtr.partitions_and_trees);
    io.CheckAssertion ("protein_gtr.partition_count==1", "This analysis can only handle a single partition");



    protein_gtr.filter_specification = alignments.DefineFiltersForPartitions (protein_gtr.partitions_and_trees,
                                                                            "protein_gtr.msa" ,
                                                                            "protein_gtr.filter.",
                                                                            protein_gtr.file_info);


    protein_gtr.full_trees = utility.Map (protein_gtr.partitions_and_trees, "_value_", '_value_[terms.data.tree]');
    protein_gtr.full_data_filter = utility.Map (protein_gtr.filter_specification, "_value_", "_value_[terms.data.name]");


    /********** Store dataset information *************/
    /* CURRENTLY DOESN'T WORK IN MPI FOR REASONS TBD */
//     protein_gtr.output_data_info = { utility.getGlobalValue("terms.json.sequences"): protein_gtr.file_info[utility.getGlobalValue("terms.data.sequences")],
//                                      utility.getGlobalValue("terms.json.sites"): protein_gtr.file_info[utility.getGlobalValue("terms.data.sites")],
//                                      utility.getGlobalValue("terms.json.trees"): (protein_gtr.full_trees["0"])[utility.getGlobalValue("terms.trees.newick_with_lengths")],
//                                      utility.getGlobalValue("terms.json.file"): filename
//                                    };
// 
// 
    // In case there were no branch lengths
//     if (  Abs( (protein_gtr.full_trees["0"])[utility.getGlobalValue("terms.branch_length")] ) == 0 ){
//         protein_gtr.output_data_info[ utility.getGlobalValue("terms.json.trees") ] = (protein_gtr.full_trees["0"])[utility.getGlobalValue("terms.trees.newick")];
//     }
//     utility.ForEach (utility.Keys (protein_gtr.name_mapping), "branch_name",
//                              "utility.EnsureKey (protein_gtr.output_data_info[terms.original_name], branch_name)");
// 
//     utility.ForEach (utility.Keys (protein_gtr.name_mapping), "branch_name",
//                              "(protein_gtr.output_data_info[terms.original_name])[branch_name] = protein_gtr.name_mapping[branch_name]");
// 
// 
//     (protein_gtr.analysis_results[protein_gtr.index_to_filename[filename]])[utility.getGlobalValue("terms.json.input")] = protein_gtr.output_data_info;
// 
//     
    /****************************************************/

    
    protein_gtr.baseline_mle = estimators.FitSingleModel_Ext(protein_gtr.full_data_filter,
                                                        protein_gtr.full_trees,
                                                        protein_gtr.baseline_model_desc,
                                                        None,
                                                        None);
                                                        //
                                                        
    protein_gtr.baseline_mle - terms.global; // delete empty key
    return protein_gtr.baseline_mle;
}



/**
 * @name protein_gtr.handle_baseline_callback
 * @param node - node name which processed the given data
 * @param {Dict} result - Dictionary of fitted information for given data
 * @param {Dict} arguments - Dictionary with single key:value :: 0:datafile name
 * @description Handle MPI callback after fitting a baseline amino acid model (for initial branch length optimization)
 */
function protein_gtr.handle_baseline_callback (node, result, arguments) {

    savekey = protein_gtr.index_to_filename[arguments[0]];
    
    utility.EnsureKey(protein_gtr.analysis_results, savekey);
    utility.EnsureKey(protein_gtr.analysis_results[savekey], protein_gtr.baseline_phase);
    (protein_gtr.analysis_results[savekey])[protein_gtr.baseline_phase] = result;
     
    io.ReportProgressMessageMD ("Protein GTR Fitter", "Initial branch length fit",
                                "Received file '" + arguments[0] + "' from node " + node + ". LogL = " + result[terms.fit.log_likelihood]);
}





function protein_gtr.fitOnePass (current_results) {

    //file_list = utility.Keys (current_results); ---> protein_gtr.file_list
    //file_count = utility.Array1D (file_list);   ---> protein_gtr.file_list_count
    // NOTE: protein_gtr.index_to_filename is {filename:0, filename:1}

    partition_info = {};
    filter_info    = {};
    trees = {};
    initial_values = {terms.global : {}, terms.branch_length : {}};
    index_to_file_name   = {};

    for (file_index = 0; file_index < protein_gtr.file_list_count; file_index += 1) {
        file_path = protein_gtr.file_list [file_index];
        dataset_name = "protein_gtr.msa." + file_index;
        partition_info [file_index] = alignments.ReadNucleotideDataSet (dataset_name, file_path);
        partition_specification = { "0" : {terms.data.name : "all", terms.data.filter_string : "", term.data.tree : ((current_results[file_index])[terms.fit.trees])[0]}};


        filter_info [file_index] = (alignments.DefineFiltersForPartitions (partition_specification,
                                                                            dataset_name ,
                                                                            dataset_name,
                                                                            partition_info [file_index]))[0];
        trees [file_index] = {terms.trees.newick :  ((current_results[file_index])[terms.fit.trees])[0]};
        (initial_values[terms.branch_length])[file_index] = ((current_results[file_index])[terms.branch_length])[0];
    }

    utility.SetEnvVariable ("VERBOSITY_LEVEL", 1);
    utility.ToggleEnvVariable ("AUTO_PARALLELIZE_OPTIMIZE", 1);
    utility.ToggleEnvVariable ("OPTIMIZATION_METHOD", 0);

    // to do: clean hardcoding here!!!!!!!!
    // start with JTT, for clean xrate comparison.
    for (l1 = 0; l1 < 20; l1 += 1) {
        for (l2 = l1 + 1; l2 < 20; l2 += 1) {
            (initial_values[terms.global]) [terms.aminoacidRate (models.protein.alphabet[l1],models.protein.alphabet[l2])] = {terms.fit.MLE : (models.protein.JTT.Rij[models.protein.alphabet[l1]])[models.protein.alphabet[l2]]}; 
        }
    }
    protein_gtr.rev.mle = estimators.FitSingleModel_Ext (
                                        utility.Map (filter_info, "_value_", "_value_[terms.data.name]"),
                                        trees,
                                        protein_gtr.rev_model,
                                        initial_values,
                                         {terms.run_options.retain_lf_object : TRUE}
                                   );
                                   
                               
    lf_id = protein_gtr.rev.mle[terms.likelihood_function];
    Export(protein_gtr.finalphase_LF, ^lf_id);
    protein_gtr.rev.mle - terms.likelihood_function;
    fprintf(protein_gtr.final_likelihood_function, protein_gtr.finalphase_LF);

    // Save the rev.mle into the analysis_results, and cache it.
    (^"protein_gtr.analysis_results")[protein_gtr.final_phase] = protein_gtr.rev.mle;

    console.log (""); // clear past the optimization progress line
    utility.SetEnvVariable ("VERBOSITY_LEVEL", 0);
    utility.ToggleEnvVariable ("AUTO_PARALLELIZE_OPTIMIZE", None);
    utility.ToggleEnvVariable ("OPTIMIZATION_METHOD", None);


    // SJS: I prefer to keep this as dictionary for compatibility with rest of the output.
    protein_gtr.rev.mle[terms.fit.trees] = utility.SwapKeysAndValues(utility.MatrixToDict(protein_gtr.rev.mle[terms.fit.trees]));
    return protein_gtr.rev.mle;

}







// From the fitted model results for a given PHASE, create EFV array which can be used for custom model 
function protein_gtr.extract_efv (results, frequency_type) {
    if (frequency_type == "ML"){
        protein_gtr.fitted_efv = {protein_gtr.dim, 1};
        for (i = 0; i < protein_gtr.dim; i+=1)
        {
            efv_search = terms.characterFrequency(protein_gtr.states[i]);  
            protein_gtr.fitted_efv[i] = ((results[terms.global])[efv_search])[terms.fit.MLE];
    
        }
        norm =  +protein_gtr.fitted_efv;
        protein_gtr.fitted_efv = protein_gtr.fitted_efv * (1/norm);
    }
    if (frequency_type == "Emp") {
        protein_gtr.fitted_efv = (results[terms.efv_estimate])["VALUEINDEXORDER"][0];
    }
    //console.log((results[terms.efv_estimate])["VALUEINDEXORDER"][0]);
    //console.log(protein_gtr.fitted_efv);
    return protein_gtr.fitted_efv
}




// From the fitted model results for a given PHASE, create rate dictionary which can be used for custom model 
function protein_gtr.extract_rates (results) {

    protein_gtr.rij = {};
    for (l1 = 0; l1 < protein_gtr.dim - 1; l1 += 1) {
        protein_gtr.rij[protein_gtr.states[l1]] = {};
        for (l2 = l1 + 1; l2 < protein_gtr.dim; l2 += 1) {
    
            rate_search = terms.aminoacidRate(protein_gtr.states[l1], protein_gtr.states[l2]);       
            (protein_gtr.rij[protein_gtr.states[l1]])[protein_gtr.states[l2]] = ((results[terms.global])[rate_search])[terms.fit.MLE];
        }
    }
    return protein_gtr.rij
}






